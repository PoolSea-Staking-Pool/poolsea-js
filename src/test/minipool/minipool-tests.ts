// Imports
import {assert} from 'chai';
import Web3 from 'web3';
import RocketPool from '../../rocketpool/rocketpool';
import MinipoolContract from '../../rocketpool/minipool/minipool-contract';
import {takeSnapshot, revertSnapshot, mineBlocks, increaseTime} from '../_utils/evm';
import {createMinipool, getMinipoolMinimumRPLStake, stakeMinipool} from '../_helpers/minipool';
import {close} from './scenario-close';
import {dissolve} from './scenario-dissolve';
import {refund } from './scenario-refund';
import {stake} from './scenario-stake';
import {withdrawValidatorBalance} from './scenario-withdraw-validator-balance';
import {withdraw} from './scenario-withdraw';
import {nodeStakeRPL, setNodeTrusted, setNodeWithdrawalAddress} from '../_helpers/node';
import {setDAOProtocolBootstrapSetting} from '../dao/scenario-dao-protocol-bootstrap';
import {userDeposit} from '../_helpers/deposit';
import {mintRPL} from '../_helpers/tokens';
import {printTitle} from '../_utils/formatting';
import {shouldRevert} from '../_utils/testing';
import {getValidatorPubkey} from '../_utils/beacon';
import {getNetworkSetting} from "../_helpers/settings";
import {getNodeFee} from "../_helpers/network";
import {setDaoNodeTrustedBootstrapUpgrade} from "../dao/scenario-dao-node-trusted-bootstrap";

// Tests
export default function runMinipoolTests(web3: Web3, rp: RocketPool) {
    describe('Minipool', () => {

        // settings
        const gasLimit: number = 8000000;


        // Accounts
        let owner: string;
        let node: string;
        let nodeWithdrawalAddress: string;
        let trustedNode: string;
        let dummySwc: string;
        let random: string;

        // Minipool validator keys
        const stakingMinipoolPubkey = getValidatorPubkey();
        const withdrawableMinipoolPubkey = getValidatorPubkey();


        // State snapshotting
        let suiteSnapshotId: string, testSnapshotId: string;
        before(async () => { suiteSnapshotId = await takeSnapshot(web3); });
        after(async () => { await revertSnapshot(web3, suiteSnapshotId); });
        beforeEach(async () => { testSnapshotId = await takeSnapshot(web3); });
        afterEach(async () => { await revertSnapshot(web3, testSnapshotId); });


        // Setup
        let launchTimeout = 20;
        let withdrawalDelay = 20;
        let initializedMinipool: MinipoolContract;
        let prelaunchMinipool: MinipoolContract;
        let prelaunchMinipool2: MinipoolContract;
        let stakingMinipool: MinipoolContract;
        let withdrawableMinipool: MinipoolContract;
        let dissolvedMinipool: MinipoolContract;
        let withdrawalBalance = web3.utils.toWei('36', 'ether');
        let newDelegateAddress = '0x0000000000000000000000000000000000000001'

        before(async () => {

            // Get accounts
            [owner, node, nodeWithdrawalAddress, trustedNode, dummySwc, random] = await web3.eth.getAccounts();

            // Register node & set withdrawal address
            await rp.node.registerNode('Australia/Brisbane', {from: node, gas: gasLimit});
            await setNodeWithdrawalAddress(web3, rp, node, nodeWithdrawalAddress, {from: node, gas: gasLimit});

            // Register trusted node
            await rp.node.registerNode('Australia/Brisbane', {from: trustedNode, gas: gasLimit});
            await setNodeTrusted(web3, rp, trustedNode, 'saas_1', 'node@home.com', owner);

            // Set settings
            await setDAOProtocolBootstrapSetting(web3, rp, 'rocketDAOProtocolSettingsMinipool', 'minipool.launch.timeout', launchTimeout, {from: owner, gas: gasLimit});
            await setDAOProtocolBootstrapSetting(web3, rp, 'rocketDAOProtocolSettingsMinipool', 'minipool.withdrawal.delay', withdrawalDelay, {from: owner, gas: gasLimit});

            // Make user deposit to refund first prelaunch minipool
            let refundAmount = web3.utils.toWei('16', 'ether');
            await userDeposit(web3, rp, {from: random, value: refundAmount, gas: gasLimit});

            // Stake RPL to cover minipools
            let minipoolRplStake = await getMinipoolMinimumRPLStake(web3, rp);
            let rplStake = minipoolRplStake.mul(web3.utils.toBN(6));
            await mintRPL(web3, rp, owner, node, rplStake);
            await nodeStakeRPL(web3, rp, rplStake, {from: node, gas: gasLimit});

            // Create minipools
            prelaunchMinipool = (await createMinipool(web3, rp, {from: node, value: web3.utils.toWei('32', 'ether'), gas: gasLimit}) as MinipoolContract);
            prelaunchMinipool2 = (await createMinipool(web3, rp, {from: node, value: web3.utils.toWei('32', 'ether'), gas: gasLimit}) as MinipoolContract);
            stakingMinipool = (await createMinipool(web3, rp, {from: node, value: web3.utils.toWei('32', 'ether'), gas: gasLimit}) as MinipoolContract);
            withdrawableMinipool = (await createMinipool(web3, rp, {from: node, value: web3.utils.toWei('32', 'ether'), gas: gasLimit}) as MinipoolContract);
            initializedMinipool = (await createMinipool(web3, rp, {from: node, value: web3.utils.toWei('16', 'ether'), gas: gasLimit}) as MinipoolContract);
            dissolvedMinipool = (await createMinipool(web3, rp, {from: node, value: web3.utils.toWei('16', 'ether'), gas: gasLimit}) as MinipoolContract);

            // Stake minipools
            await stakeMinipool(web3, rp, stakingMinipool, stakingMinipoolPubkey, {from: node, gas: gasLimit});
            await stakeMinipool(web3, rp, withdrawableMinipool, withdrawableMinipoolPubkey, {from: node, gas: gasLimit});

            // Set minipool to withdrawable
            await rp.minipool.submitMinipoolWithdrawable(withdrawableMinipool.address, {from: trustedNode, gas: gasLimit});

            // Dissolve minipool
            await dissolvedMinipool.dissolve({from: node, gas: gasLimit});

            // Check minipool statuses
            let initializedStatus = await initializedMinipool.contract.methods.getStatus().call().then((value: any) => web3.utils.toBN(value));
            let prelaunchStatus = await prelaunchMinipool.contract.methods.getStatus().call().then((value: any) => web3.utils.toBN(value));
            let prelaunch2Status = await prelaunchMinipool2.contract.methods.getStatus().call().then((value: any) => web3.utils.toBN(value));
            let stakingStatus = await stakingMinipool.contract.methods.getStatus().call().then((value: any) => web3.utils.toBN(value));
            let withdrawableStatus = await withdrawableMinipool.contract.methods.getStatus().call().then((value: any) => web3.utils.toBN(value));
            let dissolvedStatus = await dissolvedMinipool.contract.methods.getStatus().call().then((value: any) => web3.utils.toBN(value));
            assert(initializedStatus.eq(web3.utils.toBN(0)), 'Incorrect initialized minipool status');
            assert(prelaunchStatus.eq(web3.utils.toBN(1)), 'Incorrect prelaunch minipool status');
            assert(prelaunch2Status.eq(web3.utils.toBN(1)), 'Incorrect prelaunch minipool status');
            assert(stakingStatus.eq(web3.utils.toBN(2)), 'Incorrect staking minipool status');
            assert(withdrawableStatus.eq(web3.utils.toBN(3)), 'Incorrect withdrawable minipool status');
            assert(dissolvedStatus.eq(web3.utils.toBN(4)), 'Incorrect dissolved minipool status');

            // Check minipool refund balances
            let prelaunchRefundBalance = await prelaunchMinipool.contract.methods.getNodeRefundBalance().call().then((value: any) => web3.utils.toBN(value));
            let prelaunch2RefundBalance = await prelaunchMinipool2.contract.methods.getNodeRefundBalance().call().then((value: any) => web3.utils.toBN(value));
            assert(prelaunchRefundBalance.eq(web3.utils.toBN(refundAmount)), 'Incorrect prelaunch minipool refund balance');
            assert(prelaunch2RefundBalance.eq(web3.utils.toBN(0)), 'Incorrect prelaunch minipool refund balance');

            // Check minipool queues
            const rocketMinipoolQueue = await rp.contracts.get('rocketMinipoolQueue');
            const [totalLength, fullLength, halfLength, emptyLength] = await Promise.all([
                rocketMinipoolQueue.methods.getTotalLength().call().then((value: any) => web3.utils.toBN(value)),   // Total
                rocketMinipoolQueue.methods.getLength(1).call().then((value: any) => web3.utils.toBN(value)),       // Full
                rocketMinipoolQueue.methods.getLength(2).call().then((value: any) => web3.utils.toBN(value)),       // Half
                rocketMinipoolQueue.methods.getLength(3).call().then((value: any) => web3.utils.toBN(value)),       // Empty
            ])

            // Total should match sum
            assert(totalLength.eq(fullLength.add(halfLength).add(emptyLength)));
            assert(fullLength.toNumber() === 2, 'Incorrect number of minipools in full queue')
            assert(halfLength.toNumber() === 1, 'Incorrect number of minipools in half queue')
            assert(emptyLength.toNumber() === 0, 'Incorrect number of minipools in empty queue')

            // Upgrade the delegate contract
            await setDaoNodeTrustedBootstrapUpgrade(web3, rp, 'upgradeContract', 'rocketMinipoolDelegate', [], newDelegateAddress, {
                from: owner,
                gas: gasLimit
            });

            // Check effective delegate is still the original
            const minipoolContract = await rp.contracts.get('rocketMinipool');
            const minipool = await minipoolContract.methods.at(stakingMinipool.address).call();
            const effectiveDelegate = await minipoolContract.methods.getEffectiveDelegate().call()
            assert(effectiveDelegate !== newDelegateAddress, "Effective delegate was updated")
        });


        //
        // General
        //
        it(printTitle('random address', 'cannot send ETH to non-payable minipool delegate methods'), async () => {

            // Attempt to send ETH to view method
            await shouldRevert(prelaunchMinipool.contract.methods.getStatus().send({
                from: random,
                value: web3.utils.toWei('1', 'ether'),
                gas: gasLimit,
            }), 'Sent ETH to a non-payable minipool delegate view method', '');

            // Attempt to send ETH to mutator method
            await shouldRevert(refund(web3, rp, prelaunchMinipool, {
                from: node,
                value: web3.utils.toWei('1', 'ether'),
                gas: gasLimit
            }), 'Sent ETH to a non-payable minipool delegate mutator method', '');

        });


        // it(printTitle('minipool', 'has correct withdrawal credentials'), async () => {
        //
        //     // Withdrawal credentials settings
        //     const withdrawalPrefix = '01';
        //     const padding = '0000000000000000000000';
        //
        //     // Get minipool withdrawal credentials
        //     let withdrawalCredentials = await initializedMinipool.contract.methods.getWithdrawalCredentials().call();
        //
        //     // Check withdrawal credentials
        //     let expectedWithdrawalCredentials = ('0x' + withdrawalPrefix + padding + initializedMinipool.address.substr(2));
        //     assert.equal(withdrawalCredentials.toLowerCase(), expectedWithdrawalCredentials.toLowerCase(), 'Invalid minipool withdrawal credentials');
        //
        // });
        //
        //
        // //
        // // Refund
        // //
        // it(printTitle('node operator', 'can refund a refinanced node deposit balance'), async () => {
        //
        //     // Refund from minipool with refund balance
        //     await refund(web3, rp, prelaunchMinipool, {
        //         from: node,
        //         gas: gasLimit
        //     });
        //
        // });
        //
        //
        // it(printTitle('node operator', 'cannot refund with no refinanced node deposit balance'), async () => {
        //
        //     // Refund
        //     await refund(web3, rp, prelaunchMinipool, {from: node, gas: gasLimit});
        //
        //     // Attempt refund from minipools with no refund balance
        //     await shouldRevert(refund(web3, rp, prelaunchMinipool, {
        //         from: node,
        //         gas: gasLimit
        //     }), 'Refunded from a minipool which was already refunded from', 'No amount of the node deposit is available for refund');
        //
        //     await shouldRevert(refund(web3, rp, prelaunchMinipool2, {
        //         from: node,
        //         gas: gasLimit
        //     }), 'Refunded from a minipool with no refund balance', 'No amount of the node deposit is available for refund');
        //
        // });
        //
        //
        // it(printTitle('random address', 'cannot refund a refinanced node deposit balance'), async () => {
        //
        //     // Attempt refund from minipool with refund balance
        //     await shouldRevert(refund(web3, rp, prelaunchMinipool, {
        //         from: random,
        //         gas: gasLimit
        //     }), 'Random address refunded from a minipool', 'Invalid minipool owner');
        //
        // });
        //
        //
        // //
        // // Dissolve
        // //
        // it(printTitle('node operator', 'can dissolve their own minipools'), async () => {
        //
        //     // Dissolve minipools
        //     await dissolve(web3, rp, initializedMinipool, {
        //         from: node,
        //         gas: gasLimit
        //     });
        //     await dissolve(web3, rp, prelaunchMinipool, {
        //         from: node,
        //         gas: gasLimit
        //     });
        //
        // });
        //
        //
        // it(printTitle('node operator', 'cannot dissolve their own staking minipools'), async () => {
        //
        //     // Attempt to dissolve staking minipool
        //     await shouldRevert(dissolve(web3, rp, stakingMinipool, {
        //         from: node,
        //         gas: gasLimit
        //     }), 'Dissolved a staking minipool', 'The minipool can only be dissolved while initialized or in prelaunch');
        //
        // });
        //
        //
        // it(printTitle('random address', 'can dissolve a timed out minipool at prelaunch'), async () => {
        //
        //     // Time prelaunch minipool out
        //     await mineBlocks(web3, launchTimeout);
        //
        //     // Dissolve prelaunch minipool
        //     await dissolve(web3, rp, prelaunchMinipool, {
        //         from: random,
        //         gas: gasLimit
        //     });
        //
        // });
        //
        //
        // it(printTitle('random address', 'cannot dissolve a minipool which is not at prelaunch'), async () => {
        //
        //     // Time prelaunch minipool out
        //     await mineBlocks(web3, launchTimeout);
        //
        //     // Attempt to dissolve initialized minipool
        //     await shouldRevert(dissolve(web3, rp, initializedMinipool, {
        //         from: random,
        //         gas: gasLimit
        //     }), 'Random address dissolved a minipool which was not at prelaunch', 'The minipool can only be dissolved by its owner unless it has timed out');
        //
        // });
        //
        //
        // it(printTitle('random address', 'cannot dissolve a minipool which has not timed out'), async () => {
        //
        //     // Attempt to dissolve prelaunch minipool
        //     await shouldRevert(dissolve(web3, rp, prelaunchMinipool, {
        //         from: random,
        //     }), 'Random address dissolved a minipool which has not timed out', 'The minipool can only be dissolved by its owner unless it has timed out');
        //
        // });
        //
        // //
        // // Stake
        // //
        // it(printTitle('node operator', 'can stake a minipool at prelaunch'), async () => {
        //
        //     // Stake prelaunch minipool
        //     await stake(web3, rp, prelaunchMinipool, getValidatorPubkey(), "", {
        //         from: node,
        //         gas: gasLimit
        //     });
        //
        // });
        //
        //
        // it(printTitle('node operator', 'cannot stake a minipool which is not at prelaunch'), async () => {
        //
        //     // Attempt to stake initialized minipool
        //     await shouldRevert(stake(web3, rp, initializedMinipool, getValidatorPubkey(), "", {
        //         from: node,
        //         gas: gasLimit
        //     }), 'Staked a minipool which was not at prelaunch', 'The minipool can only begin staking while in prelaunch');
        //
        // });
        //
        //
        // it(printTitle('node operator', 'cannot stake a minipool with a reused validator pubkey'), async () => {
        //
        //     // Get pubkey
        //     let pubkey = getValidatorPubkey();
        //
        //     // Stake prelaunch minipool
        //     await stake(web3, rp, prelaunchMinipool, pubkey, "", {from: node, gas: gasLimit});
        //
        //     // Attempt to stake second prelaunch minipool with same pubkey
        //     await shouldRevert(stake(web3, rp, prelaunchMinipool2, pubkey, "", {
        //         from: node,
        //         gas: gasLimit
        //     }), 'Staked a minipool with a reused validator pubkey', 'Validator pubkey is already in use');
        //
        // });
        //
        //
        // it(printTitle('node operator', 'cannot stake a minipool with incorrect withdrawal credentials'), async () => {
        //
        //     // Get withdrawal credentials
        //     let invalidWithdrawalCredentials = '0x1111111111111111111111111111111111111111111111111111111111111111';
        //
        //     // Attempt to stake prelaunch minipool
        //     await shouldRevert(stake(web3, rp, prelaunchMinipool, getValidatorPubkey(), invalidWithdrawalCredentials, {
        //         from: node,
        //         gas: gasLimit
        //     }), 'Staked a minipool with incorrect withdrawal credentials', 'Transaction reverted silently');
        //
        // });
        //
        //
        // it(printTitle('random address', 'cannot stake a minipool'), async () => {
        //
        //     // Attempt to stake prelaunch minipool
        //     await shouldRevert(stake(web3, rp, prelaunchMinipool, getValidatorPubkey(), "", {
        //         from: random,
        //         gas: gasLimit
        //     }), 'Random address staked a minipool', 'Invalid minipool owner');
        //
        // });
        //
        //
        // //
        // // Withdraw validator balance
        // //
        // it(printTitle('random', 'random address cannot withdraw and destroy a node operators minipool balance'), async () => {
        //
        //     // Wait 14 days
        //     await increaseTime(web3, 60 * 60 * 24 * 14 + 1)
        //     // Attempt to send validator balance
        //     await shouldRevert(withdrawValidatorBalance(web3, rp, withdrawableMinipool, withdrawalBalance, random, true), 'Random address withdrew validator balance from a node operators minipool', "Only node operator can destroy minipool");
        //
        // });
        //
        // it(printTitle('random', 'random address can trigger a payout of withdrawal balance if balance is greater than 16 ETH'), async () => {
        //
        //     // Wait 14 days
        //     await increaseTime(web3, 60 * 60 * 24 * 14 + 1)
        //     // Attempt to send validator balance
        //     await withdrawValidatorBalance(web3, rp, withdrawableMinipool, withdrawalBalance, random, false);
        //
        // });
        //
        // it(printTitle('random', 'random address cannot trigger a payout of withdrawal balance if balance is less than 16 ETH'), async () => {
        //
        //     // Attempt to send validator balance
        //     await shouldRevert(withdrawValidatorBalance(web3, rp, withdrawableMinipool, web3.utils.toWei('15', 'ether'), random, false), 'Random address was able to execute withdraw on sub 16 ETH minipool', 'Non-owner must wait 14 days after withdrawal to distribute balance');
        //
        // });
        //
        // it(printTitle('node operator withdrawal address', 'can withdraw their ETH once it is received, then distribute ETH to the rETH contract / deposit pool and destroy the minipool'), async () => {
        //
        //     // Send validator balance and withdraw
        //     await withdrawValidatorBalance(web3, rp, withdrawableMinipool, withdrawalBalance, nodeWithdrawalAddress, true);
        //
        // });
        //
        // it(printTitle('node operator account', 'can also withdraw their ETH once it is received, then distribute ETH to the rETH contract / deposit pool and destroy the minipool'), async () => {
        //
        //     // Send validator balance and withdraw
        //     await withdrawValidatorBalance(web3, rp, withdrawableMinipool, withdrawalBalance, node, true);
        //
        // });
        //
        //
        // it(printTitle('malicious node operator', 'can not prevent a payout by using a reverting contract as withdraw address'), async () => {
        //
        //     // Set the node's withdraw address to a reverting contract
        //     const revertOnTransfer = await rp.contracts.get('revertOnTransfer');
        //     await setNodeWithdrawalAddress(web3, rp, node, revertOnTransfer.options.address, {from: nodeWithdrawalAddress, gas: gasLimit});
        //     // Wait 14 days
        //     await increaseTime(web3, 60 * 60 * 24 * 14 + 1)
        //     // Send validator balance and withdraw and should not revert
        //     await withdrawValidatorBalance(web3, rp, withdrawableMinipool, withdrawalBalance, random, false);
        //
        // });
        //
        //
        // it(printTitle('random address', 'can send validator balance to a withdrawable minipool in one transaction'), async () => {
        //
        //     await web3.eth.sendTransaction({
        //         from: random,
        //         to: withdrawableMinipool.address,
        //         value: withdrawalBalance,
        //         gas: gasLimit
        //     });
        //
        //     // Wait 14 days
        //     await increaseTime(web3, 60 * 60 * 24 * 14 + 1)
        //     // Process validator balance
        //     await withdrawValidatorBalance(web3, rp, withdrawableMinipool, '0', random, false);
        //
        // });
        //
        //
        // it(printTitle('random address', 'can send validator balance to a withdrawable minipool across multiple transactions'), async () => {
        //
        //     // Get tx amount (half of withdrawal balance)
        //     let amount1 = web3.utils.toBN(withdrawalBalance).div(web3.utils.toBN(2));
        //     let amount2 = web3.utils.toBN(withdrawalBalance).sub(amount1);
        //
        //     await web3.eth.sendTransaction({
        //         from: random,
        //         to: withdrawableMinipool.address,
        //         value: amount1,
        //         gas: gasLimit
        //     });
        //
        //     await web3.eth.sendTransaction({
        //         from: owner,
        //         to: withdrawableMinipool.address,
        //         value: amount2,
        //         gas: gasLimit
        //     });
        //
        //     // Wait 14 days
        //     await increaseTime(web3, 60 * 60 * 24 * 14 + 1)
        //     // Process payout
        //     await withdrawValidatorBalance(web3, rp, withdrawableMinipool, '0', random, false);
        //
        //
        // });
        //
        //
        // //
        // // Close
        // //
        // it(printTitle('node operator', 'can close a dissolved minipool'), async () => {
        //
        //     // Close dissolved minipool
        //     await close(web3, rp, dissolvedMinipool, {
        //         from: node,
        //         gas: gasLimit
        //     });
        //
        // });
        //
        //
        // it(printTitle('node operator', 'cannot close a minipool which is not dissolved'), async () => {
        //
        //     // Attempt to close staking minipool
        //     await shouldRevert(close(web3, rp, stakingMinipool, {
        //         from: node,
        //         gas: gasLimit,
        //     }), 'Closed a minipool which was not dissolved', 'The minipool can only be closed while dissolved');
        //
        // });
        //
        //
        // it(printTitle('random address', 'cannot close a dissolved minipool'), async () => {
        //
        //     // Attempt to close dissolved minipool
        //     await shouldRevert(close(web3, rp, dissolvedMinipool, {
        //         from: random,
        //         gas: gasLimit,
        //     }), 'Random address closed a minipool', 'Invalid minipool owner');
        //
        // });
        //
        //
        // //
        // // Unbonded minipools
        // //
        // it(printTitle('trusted node', 'cannot create an unbonded minipool if node fee is < 80% of maximum'), async () => {
        //     // Sanity check that current node fee is less than 80% of maximum
        //     let nodeFee = await getNodeFee(web3, rp).then((value: any) => web3.utils.toBN(value));
        //     let maximumNodeFee = await getNetworkSetting(rp, 'MaximumNodeFee').then((value: any) => web3.utils.toBN(value));
        //     assert(nodeFee.lt(maximumNodeFee.muln(0.8)), 'Node fee is greater than 80% of maximum fee');
        //
        //     // Stake RPL to cover minipool
        //     let minipoolRplStake = await getMinipoolMinimumRPLStake(web3, rp);
        //     let rplStake = minipoolRplStake.mul(web3.utils.toBN(6));
        //     await mintRPL(web3, rp, owner, trustedNode, rplStake);
        //     await nodeStakeRPL(web3, rp, rplStake, {from: trustedNode, gas: gasLimit});
        //
        //     // Creating an unbonded minipool should revert
        //     await shouldRevert(createMinipool(web3, rp, {from: trustedNode, value: '0', gas: gasLimit}),
        //         'Trusted node was able to create unbonded minipool with fee < 80% of max',
        //         'Current commission rate is not high enough to create unbonded minipools'
        //     );
        // });
        //
        //
        // it(printTitle('trusted node', 'can create an unbonded minipool if node fee is > 80% of maximum'), async () => {
        //     // Deposit enough unassigned ETH to increase the fee above 80% of max
        //     await userDeposit(web3, rp, {from: random, value: web3.utils.toWei('900', 'ether'), gas: gasLimit});
        //
        //     // Sanity check that current node fee is greater than 80% of maximum
        //     let nodeFee = await getNodeFee(web3, rp).then((value: any) => web3.utils.toBN(value));
        //     let maximumNodeFee = await getNetworkSetting(rp, 'MaximumNodeFee').then((value: any) => web3.utils.toBN(value));
        //     assert(nodeFee.gt(maximumNodeFee.muln(0.8)), 'Node fee is not greater than 80% of maximum fee');
        //
        //     // Stake RPL to cover minipool
        //     let minipoolRplStake = await getMinipoolMinimumRPLStake(web3, rp);
        //     let rplStake = minipoolRplStake.mul(web3.utils.toBN(6));
        //     await mintRPL(web3, rp, owner, trustedNode, rplStake);
        //     await nodeStakeRPL(web3, rp, rplStake, {from: trustedNode, gas: gasLimit});
        //
        //     // Creating the unbonded minipool
        //     await createMinipool(web3, rp,{from: trustedNode, value: '0', gas: gasLimit});
        // });


    });
};
